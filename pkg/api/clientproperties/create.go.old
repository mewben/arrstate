package clientproperties

import (
	"log"

	"github.com/gofiber/fiber"
	"github.com/mewben/realty278/internal/enums"
	"github.com/mewben/realty278/pkg/errors"
	"github.com/mewben/realty278/pkg/models"
	"go.mongodb.org/mongo-driver/bson"
)

// Create -
// Apply a client to own a property
func (h *Handler) Create(data *Payload) (*SingleResponse, error) {
	// validate payload
	if err := validate.Struct(data); err != nil {
		log.Println("error validate", err)
		return nil, errors.NewHTTPError(errors.ErrInputInvalid, err)
	}

	// get the property document
	foundproperty := h.DB.FindByID(h.Ctx, enums.CollProperties, data.PropertyID, h.Business.ID)
	if foundproperty == nil {
		return nil, errors.NewHTTPError(errors.ErrNotFoundProperty)
	}
	property := foundproperty.(*models.PropertyModel)
	if property.ClientPropertyID != nil {
		return nil, errors.NewHTTPError(errors.ErrPropertyAlreadyTaken)
	}

	// get the client doc
	foundclient := h.DB.FindByID(h.Ctx, enums.CollPeople, data.ClientID, h.Business.ID)
	if foundclient == nil {
		return nil, errors.NewHTTPError(errors.ErrNotFoundPerson)
	}
	client := foundclient.(*models.PersonModel)

	// get the agent doc if present
	if data.AgentID != nil {
		foundagent := h.DB.FindByID(h.Ctx, enums.CollPeople, *data.AgentID, h.Business.ID)
		if foundagent == nil {
			return nil, errors.NewHTTPError(errors.ErrNotFoundPerson)
		}
	}

	clientproperty := models.NewClientPropertyModel(h.User.ID, h.Business.ID)
	clientproperty.PropertyID = property.ID
	clientproperty.ClientID = client.ID
	clientproperty.AgentID = data.AgentID
	clientproperty.Status = enums.StatusPending
	clientproperty.Price = property.Price + property.PriceAddon
	clientproperty.DownPayment = data.DownPayment
	clientproperty.Months = data.Months
	clientproperty.Monthly = data.Monthly // TODO: ask if this will be autogenerated or can be entered manually
	clientproperty.Date = data.Date
	clientproperty.MetaModel = data.MetaModel

	doc, err := h.DB.InsertOne(h.Ctx, enums.CollClientProperties, clientproperty)
	if err != nil || doc == nil {
		log.Println("insertonerr", err)
		return nil, errors.NewHTTPError(errors.ErrInsert, err)
	}

	// TODO: create hooks
	clientproperty = doc.(*models.ClientPropertyModel)

	// update property
	property.Status = enums.StatusPending
	property.ClientPropertyID = &clientproperty.ID
	updProperty := fiber.Map{
		"status":           enums.StatusPending,
		"clientPropertyID": &clientproperty.ID,
	}
	op := bson.D{
		{
			Key:   "$set",
			Value: updProperty,
		},
		{
			Key: "$currentDate",
			Value: fiber.Map{
				"updatedAt": true,
			},
		},
	}
	foundproperty = h.DB.FindByIDAndUpdate(h.Ctx, enums.CollProperties, property.ID, op)
	if doc == nil {
		return nil, errors.NewHTTPError(errors.ErrUpdate)
	}

	property = foundproperty.(*models.PropertyModel)

	response := &SingleResponse{
		ClientProperty: clientproperty,
		Property:       property,
	}

	return response, nil
}
